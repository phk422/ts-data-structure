# 排序算法

## 1. 冒泡排序

冒泡排序是一种简单直观的排序算法，其基本思想是通过不断比较和交换相邻的元素，将较大的元素逐步移动到数组的末尾。让我们对冒泡排序的算法复杂度进行更详细的分析：

### 1.1. 时间复杂度：

- **最好情况时间复杂度：** 在最好的情况下，即数组已经是有序的，冒泡排序需要进行 n-1 次比较，没有发生任何交换。因此，最好情况时间复杂度是 O(n)。
- **最坏情况时间复杂度：** 在最坏的情况下，即数组是逆序的，冒泡排序需要进行 n(n-1)/2 次比较和同样次数的交换。因此，最坏情况时间复杂度是 O(n^2)。
- **平均情况时间复杂度：** 在平均情况下，对于一个长度为 n 的数组，平均需要进行 n(n-1)/4 次比较和同样次数的交换。因此，平均情况时间复杂度也是 O(n^2)。

### 1.2. 空间复杂度：

冒泡排序是一种原地排序算法，不需要额外的空间，只需要常数级别的辅助空间用于交换。因此，空间复杂度是 O(1)。

### 1.3. 稳定性：

冒泡排序是一种稳定的排序算法。当两个相邻元素大小相等时，它们不会交换位置，因此相对的元素顺序保持不变。

### 1.4. 总结：

虽然冒泡排序的时间复杂度较高，但由于其实现简单，对于小规模数据或者已经基本有序的数据集，冒泡排序仍然是一个可以考虑的选择。然而，在大规模数据集上，更高效的排序算法通常会更合适。

## 2. 选择排序


选择排序（Selection Sort）是一种简单的排序算法，其基本思想是通过每次选择未排序部分的最小元素，并将其放置在已排序部分的末尾。让我们对选择排序的算法复杂度进行分析：

### 2.1. 时间复杂度：

- **最好情况时间复杂度：** 在每一轮选择中，都要找出未排序部分的最小元素，然后和已排序部分的末尾元素交换位置。最好情况下，数组已经是有序的，但选择排序仍然需要进行 n-1 次比较。因此，最好情况时间复杂度是 O(n^2)。
- **最坏情况时间复杂度：** 在最坏的情况下，即数组是逆序的，选择排序仍然需要进行 n(n-1)/2 次比较。因此，最坏情况时间复杂度是 O(n^2)。
- **平均情况时间复杂度：** 选择排序在平均情况下同样需要进行 n(n-1)/2 次比较。因此，平均情况时间复杂度也是 O(n^2)。

### 2.2. 空间复杂度：

选择排序是一种原地排序算法，只需要常数级别的辅助空间用于交换。因此，空间复杂度是 O(1)。

### 2.3. 稳定性：

选择排序是一种不稳定的排序算法。在每一轮选择中，最小元素可能会与已排序部分的元素交换位置，导致相等元素的相对顺序发生变化。

### 2.4. 总结：

选择排序的主要优点是简单直观，对于小规模数据或者简单应用场景可能是一种合理的选择。然而，由于其时间复杂度较高，对于大规模数据集，更高效的排序算法通常更为适用。